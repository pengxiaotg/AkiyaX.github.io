---
title: 'C#设计模式概述'
date: 2020-03-14 02:20:58
category: 设计模式
tags: .NET
id: csharp-design-pattern
---

# 前言

工作一段时间后才发现设计模式的重要性，实现同样功能的代码，人家的代码看着如此舒适，却又说不出好在哪里😟，我想就应该是差在内功了。大三准备面试时也粗略学过一段时间设计模式，但因为缺乏工程经验，没有深切体会，现在重新捡起温习。

本系列博客主要参考刘伟博士著作的《C#设计模式》一书👍，结合本人的实践与思考而写成，同时参阅网络上各位大佬的总结，不再列出。

🍺源码汇总： https://github.com/AkiyaX/CSharpDesignPattern

![《C#设计模式》 - 封面](./images/C#设计模式封面.jpg)

# 概览

最早将模式思想引入软件工程方法学的是Gang of Four（GOF）自称的四位软件工程学者，分别是Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides，他们在1994年归纳发表了23种在软件开发领域较为常用的设计模式。GOF对设计模式的定义：

>**设计模式**是在特定环境下为解决某一通用软件设计问题提供的一套定制解决方案，该方案描述了类和对象之间的相互作用。
>**Design patterns** are desriptions of communicating objects and classes that are custormized to solve a general design problem in a particular context.

## 创建型模式

[**抽象工厂模式**](#)（Abstract Fatory Pattern）：提供一个创建一系列相关或互相依赖对象的接口，而无须指定它们具体的类。

[**建造者模式**]()（Builder Pattern）：将一个复杂对象的构建与它的表示分离，使得同样的构造过程可以创建不同的表示。

**工厂方法模式**（Factory Method Pattern）：定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到子类。

**原型模式**（Prototype Pattern）：使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。

**单例模式**（Singleton Pattern）：确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。

## 结构型模式

**适配器模式**（Adapter Pattern）：将一个类的接口转换成客户希望看到的另一个接口，适配器模式让那些接口不兼容的类可以一起工作。

**桥接模式**（Bridge Pattern）：将抽象部分与它的实现部分解耦，使得两者都能够独立变化。

**组合模式**（Composite Pattern）：组合多个对象形成树形结构以表示具有部分——整体关系的层次结构，组合模式让客户端可以统一对待单个对象和组合对象。

**装饰模式**（Decorator Pattern）：动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰器模式提供了一种比子类更加灵活的替代方案。

**外观模式**（Facade Pattern）：为子系统种的一组接口提供一个统一的入口，这个接口使得这一子系统更加容易使用。

**享元模式**（Flyweight Pattern）：运用共享技术有效地支持大量细粒度对象的复用。

**代理模式**（Proxy Pattern）：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。

## 行为型模式

**职责链模式**（Chain of Responsibility Pattern）：避免将一个请求的发送者与接收者耦合在一起，让多个对象都有机会处理请求；将接受请求的对象连接成一条链，并且沿着这条链传递请求，指导一个对象能够处理它为止。

**命令模式**（Command Pattern）：将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。

**解释器模式**（Interperter Pattern）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

**迭代器模式**（Iterator Pattern）：提供一种方法顺序访问一个聚合对象中的各个元素，而又不用暴露该对象的内部表示。

**中介者模式**（Mediator Pattern）：定义一个对象来封装一系列对象的交互。中介者模式使各对象之间不需要显式地互相引用，从而使其耦合松散，而且让你可以独立地改变它们之间的交互。

**备忘录模式**（Memento Pattern）：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。

**观察者模式**（Observer Pattern）：定义对象之间的一种一对多依赖关系，使得每当一个对象状态覆盖发生改变时，其相关依赖对象皆得到通知并被自动更新。

**状态模式**（State Pattern）：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。

****（）：。